{"version":3,"file":"svg64.umd.js","sources":["../src/svg64.ts"],"sourcesContent":["// prettier-ignore\nconst CHARS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\nconst PREFIX = 'data:image/svg+xml;base64,';\n\nexport const utf8Encode = (input: string): string => {\n\tinput = input.replace(/\\r\\n/g, '\\n');\n\n\tlet i = 0;\n\tlet output = '';\n\n\tfor (; i < input.length; i++) {\n\t\tconst c = input.charCodeAt(i);\n\n\t\tif (c < 128) {\n\t\t\toutput += String.fromCharCode(c);\n\t\t} else if (c > 127 && c < 2048) {\n\t\t\toutput += String.fromCharCode((c >> 6) | 192);\n\t\t\toutput += String.fromCharCode((c & 63) | 128);\n\t\t} else {\n\t\t\toutput += String.fromCharCode((c >> 12) | 224);\n\t\t\toutput += String.fromCharCode(((c >> 6) & 63) | 128);\n\t\t\toutput += String.fromCharCode((c & 63) | 128);\n\t\t}\n\t}\n\n\treturn output;\n};\n\nexport const encode = (input: string): string => {\n\tlet i = 0;\n\tlet chr1: number;\n\tlet chr2: number;\n\tlet chr3: number;\n\tlet enc1: number;\n\tlet enc2: number;\n\tlet enc3: number;\n\tlet enc4: number;\n\tlet output = '';\n\n\tinput = utf8Encode(input);\n\n\twhile (i < input.length) {\n\t\tchr1 = input.charCodeAt(i++);\n\t\tchr2 = input.charCodeAt(i++);\n\t\tchr3 = input.charCodeAt(i++);\n\n\t\tenc1 = chr1 >> 2;\n\t\tenc2 = ((chr1 & 3) << 4) | (chr2 >> 4);\n\t\tenc3 = ((chr2 & 15) << 2) | (chr3 >> 6);\n\t\tenc4 = chr3 & 63;\n\n\t\tif (isNaN(chr2)) {\n\t\t\tenc3 = enc4 = 64;\n\t\t} else if (isNaN(chr3)) {\n\t\t\tenc4 = 64;\n\t\t}\n\n\t\toutput = output + CHARS.charAt(enc1) + CHARS.charAt(enc2) + CHARS.charAt(enc3) + CHARS.charAt(enc4);\n\t}\n\n\treturn output;\n};\n\nexport const detectInputType = (input: string | SVGElement): 'string' | 'element' | void => {\n\tif (typeof input === 'string') {\n\t\treturn 'string';\n\t}\n\n\tif (typeof SVGElement !== 'undefined' && input instanceof SVGElement) {\n\t\treturn 'element';\n\t}\n};\n\nexport const getBase64 = (input: string) => PREFIX + encode(input);\n\nexport const convertElement = (input: SVGElement): string => getBase64(new XMLSerializer().serializeToString(input));\n\nexport const svg64 = (input: string | SVGElement): string => {\n\tconst type = detectInputType(input);\n\n\tswitch (type) {\n\t\tcase 'string':\n\t\t\treturn getBase64(input as string);\n\n\t\tcase 'element':\n\t\t\treturn convertElement(input as SVGElement);\n\n\t\tdefault:\n\t\t\treturn input as string;\n\t}\n};\n\nexport default svg64;\n"],"names":["CHARS","utf8Encode","input","replace","i","output","length","c","charCodeAt","String","fromCharCode","encode","chr1","chr2","chr3","enc1","enc2","enc3","enc4","isNaN","charAt","detectInputType","SVGElement","getBase64","PREFIX","convertElement","XMLSerializer","serializeToString","svg64"],"mappings":"+NACA,IAAMA,EAAQ,oEAGDC,EAAa,SAACC,GAC1BA,EAAQA,EAAMC,QAAQ,QAAS,MAK/B,IAHA,IAAIC,EAAI,EACJC,EAAS,GAEND,EAAIF,EAAMI,OAAQF,IAAK,CAC7B,IAAOG,EAAGL,EAAMM,WAAWJ,GAEvBG,EAAI,IACPF,GAAUI,OAAOC,aAAaH,GACpBA,EAAI,KAAOA,EAAI,MACzBF,GAAUI,OAAOC,aAAcH,GAAK,EAAK,KACzCF,GAAUI,OAAOC,aAAkB,GAAJH,EAAU,OAEzCF,GAAUI,OAAOC,aAAcH,GAAK,GAAM,KAC1CF,GAAUI,OAAOC,aAAeH,GAAK,EAAK,GAAM,KAChDF,GAAUI,OAAOC,aAAkB,GAAJH,EAAU,KAE1C,CAED,OAAOF,CACR,EAEaM,EAAS,SAACT,GACtB,IACgBU,EACZC,EACAC,EACYC,EACAC,EACZC,EACYC,EAPXd,EAAG,EAQJC,EAAS,GAIb,IAFAH,EAAQD,EAAWC,GAEZE,EAAIF,EAAMI,QAKhBS,GAJAH,EAAOV,EAAMM,WAAWJ,OAIT,EACfY,GAAgB,EAAPJ,IAAa,GAJtBC,EAAOX,EAAMM,WAAWJ,OAIY,EACpCa,GAAgB,GAAPJ,IAAc,GAJvBC,EAAOZ,EAAMM,WAAWJ,OAIa,EACrCc,EAAc,GAAPJ,EAEHK,MAAMN,GACTI,EAAOC,EAAO,GACJC,MAAML,KAChBI,EAAO,IAGRb,EAASA,EAASL,EAAMoB,OAAOL,GAAQf,EAAMoB,OAAOJ,GAAQhB,EAAMoB,OAAOH,GAAQjB,EAAMoB,OAAOF,GAG/F,OAAOb,CACR,EAE4BgB,EAAG,SAACnB,GAC/B,MAAqB,iBAALA,EACR,SAGkB,oBAAfoB,YAA8BpB,aAAiBoB,WAClD,eADR,CAGD,EAEsBC,EAAG,SAACrB,GAAkBsB,MAvE7B,6BAuEsCb,EAAOT,EAAM,EAErDuB,EAAiB,SAACvB,GAAiB,OAAsBqB,GAAC,IAAiBG,eAAGC,kBAAkBzB,GAAO,EAElG0B,EAAG,SAAC1B,GAGrB,OAFamB,EAAgBnB,IAG5B,IAAK,SACJ,OAAOqB,EAAUrB,GAElB,IAAK,UACJ,SAAsBA,GAEvB,QACC,OAAsBA,EAEzB"}