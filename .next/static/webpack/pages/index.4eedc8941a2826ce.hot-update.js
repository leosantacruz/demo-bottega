"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/index",{

/***/ "./utils/sketchfab.ts":
/*!****************************!*\
  !*** ./utils/sketchfab.ts ***!
  \****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"addTexture\": function() { return /* binding */ addTexture; },\n/* harmony export */   \"changeColor\": function() { return /* binding */ changeColor; },\n/* harmony export */   \"emissionAnimation\": function() { return /* binding */ emissionAnimation; },\n/* harmony export */   \"fastChangeMainColor\": function() { return /* binding */ fastChangeMainColor; },\n/* harmony export */   \"generateScreenshot\": function() { return /* binding */ generateScreenshot; },\n/* harmony export */   \"getCamera\": function() { return /* binding */ getCamera; },\n/* harmony export */   \"getMaterials\": function() { return /* binding */ getMaterials; },\n/* harmony export */   \"getNodeList\": function() { return /* binding */ getNodeList; },\n/* harmony export */   \"initService\": function() { return /* binding */ initService; },\n/* harmony export */   \"setCamera\": function() { return /* binding */ setCamera; },\n/* harmony export */   \"setMetallic\": function() { return /* binding */ setMetallic; },\n/* harmony export */   \"setTexture\": function() { return /* binding */ setTexture; },\n/* harmony export */   \"setUVscale\": function() { return /* binding */ setUVscale; },\n/* harmony export */   \"toggleNode\": function() { return /* binding */ toggleNode; }\n/* harmony export */ });\nlet api = null;\nlet materials = [];\nlet nodes = [];\n//Set Sektfhcab API to make it available\nconst initService = (apiRef, materialList, nodeList)=>{\n    api = apiRef;\n    materials = materialList;\n    nodes = nodeList;\n    console.log(materialList);\n};\nconst getMaterials = ()=>{\n    return materials;\n};\nconst getNodeList = ()=>{\n    return nodes;\n};\nconst getCamera = ()=>{\n    api.getCameraLookAt(function(err, camera) {\n        console.log(camera.position); // [x, y, z]\n        console.log(camera.target); // [x, y, z]\n    });\n};\nconst setCamera = (param)=>{\n    let { position , target  } = param;\n    api.setCameraLookAt(position, target, 2);\n};\nconst changeColor = async (part, colorCode)=>{\n    let index = materials.findIndex((m)=>{\n        return m.name === part;\n    });\n    //materials[index].channels.AlbedoPBR.color = [color.r / 255, color.g / 255, color.b / 255];\n    materials[index].channels.AlbedoPBR.color = [\n        convertRGBtoLinear(colorCode.r),\n        convertRGBtoLinear(colorCode.g),\n        convertRGBtoLinear(colorCode.b)\n    ];\n    await api.setMaterial(materials[index]);\n};\nconst fastChangeMainColor = (param)=>{\n    let { r , g , b  } = param;\n    materials[13].channels.AlbedoPBR.color = [\n        convertRGBtoLinear(r),\n        convertRGBtoLinear(g),\n        convertRGBtoLinear(b)\n    ];\n    api.setMaterial(materials[13]);\n};\nconst addTexture = async (base64)=>{\n    return new Promise((resolve, reject)=>{\n        api.addTexture(base64, function(err, id) {\n            if (!err) {\n                resolve(id);\n            } else {\n                reject(err);\n            }\n        });\n    });\n};\nconst setTexture = (part, textureUid)=>{\n    let index = materials.findIndex((m)=>{\n        return m.name === part;\n    });\n    materials[index].channels.AlbedoPBR = {\n        texture: {\n            uid: textureUid\n        }\n    };\n    materials[index].channels.AlbedoPBR.factor = 1;\n    api.setMaterial(materials[index], ()=>{});\n};\nconst setUVscale = (part)=>{\n    let index = materials.findIndex((m)=>{\n        return m.name === part;\n    });\n    api.setUVScale(materials[index], \"AlbedoPBR\", 10, 10);\n};\nconst toggleNode = (node, action)=>{\n    let instanceID = nodes.filter((r)=>{\n        return r.name === node;\n    });\n    if (instanceID[0]) {\n        if (action == \"show\") {\n            api.show(instanceID[0].instanceID);\n        } else {\n            api.hide(instanceID[0].instanceID);\n        }\n    }\n};\nfunction convertColor(color) {\n    return [\n        color.r,\n        color.g,\n        color.b\n    ];\n}\nconst generateScreenshot = async ()=>{\n    let camera = {\n        position: [\n            -71.71309445654904,\n            -57.16881106698193,\n            32.2789393429998\n        ],\n        target: [\n            2.701051515138964,\n            0.00007667749023099191,\n            4.360299098332644\n        ]\n    };\n    await api.setCameraLookAt(camera.position, camera.target, 0);\n    let screenshot = await makeScreenshot();\n    return screenshot;\n};\nconst makeScreenshot = async ()=>{\n    return new Promise((resolve, reject)=>{\n        api.getScreenShot(700, 394, \"image/png\", function(error, result) {\n            if (error) {\n                reject(error);\n            } else {\n                const base64WithoutHeader = result.substring(result.indexOf(\",\") + 1);\n                resolve(base64WithoutHeader);\n            }\n        });\n    });\n};\nfunction convertRGBtoLinear(color) {\n    let value = color / 255;\n    if (value <= 0 && value <= 0.04045) {\n        return value / 12.92;\n    } else {\n        return ((value + 0.055) / 1.055) ** 2.4;\n    }\n}\nasync function setMetallic(material, value) {\n    if (value) {\n        material.channels.MetalnessPBR.factor = 1;\n        material.channels.RoughnessPBR.factor = 0.6;\n    } else {\n        material.channels.MetalnessPBR.factor = 0;\n        material.channels.RoughnessPBR.factor = 0.2;\n    }\n    await api.setMaterial(materials[13]);\n}\nfunction emissionAnimation(part) {\n    let index = materials.findIndex((m)=>{\n        return m.name === part;\n    });\n    function changeEmitFactor(i) {\n        materials[index].channels.EmitColor.enable = true;\n        materials[index].channels.EmitColor.factor = i;\n        api.setMaterial(materials[index], ()=>{});\n    }\n    let number = 0;\n    let increment = 0.025;\n    function animateNumber() {\n        number += increment;\n        if (number >= 0.4) {\n            increment = -increment;\n        }\n        if (number > 0) {\n            setTimeout(animateNumber, 10); // Llamar a la función nuevamente después de 10 milisegundos\n        }\n        changeEmitFactor(number);\n    }\n    animateNumber();\n}\n\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QVcsQ0FBQ2hDLFNBQVMsQ0FBQ3FCLE1BQU0sRUFBRSxJQUFNLENBQUM7SUFDM0M7SUFFQSxJQUFJcUQsU0FBUztJQUNiLElBQUlDLFlBQVk7SUFFaEIsU0FBU0MsZ0JBQWdCO1FBQ3ZCRixVQUFVQztRQUVWLElBQUlELFVBQVUsS0FBSztZQUNqQkMsWUFBWSxDQUFDQTtRQUNmLENBQUM7UUFFRCxJQUFJRCxTQUFTLEdBQUc7WUFDZEcsV0FBV0QsZUFBZSxLQUFLLDREQUE0RDtRQUM3RixDQUFDO1FBRUROLGlCQUFpQkk7SUFDbkI7SUFDQUU7QUFDRjtBQWdCRSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi91dGlscy9za2V0Y2hmYWIudHM/Y2ZkOSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjb2xvckxpc3QgfSBmcm9tIFwiLi4vZGF0YS9jb2xvcnNcIjtcbmltcG9ydCB7IENvbG9yIH0gZnJvbSBcIi4uL2ludGVyZmFjZXMvZ2VuZXJhbFwiO1xuXG5sZXQgYXBpOiBhbnkgPSBudWxsO1xubGV0IG1hdGVyaWFsczogYW55W10gPSBbXTtcbmxldCBub2RlczogYW55W10gPSBbXTtcblxuLy9TZXQgU2VrdGZoY2FiIEFQSSB0byBtYWtlIGl0IGF2YWlsYWJsZVxuY29uc3QgaW5pdFNlcnZpY2UgPSAoYXBpUmVmOiBhbnksIG1hdGVyaWFsTGlzdDogYW55W10sIG5vZGVMaXN0OiBhbnlbXSkgPT4ge1xuICBhcGkgPSBhcGlSZWY7XG4gIG1hdGVyaWFscyA9IG1hdGVyaWFsTGlzdDtcbiAgbm9kZXMgPSBub2RlTGlzdDtcbiAgY29uc29sZS5sb2cobWF0ZXJpYWxMaXN0KTtcbn07XG5cbmNvbnN0IGdldE1hdGVyaWFscyA9ICgpID0+IHtcbiAgcmV0dXJuIG1hdGVyaWFscztcbn07XG5cbmNvbnN0IGdldE5vZGVMaXN0ID0gKCkgPT4ge1xuICByZXR1cm4gbm9kZXM7XG59O1xuXG5jb25zdCBnZXRDYW1lcmEgPSAoKSA9PiB7XG4gIGFwaS5nZXRDYW1lcmFMb29rQXQoZnVuY3Rpb24gKGVycjogYW55LCBjYW1lcmE6IGFueSkge1xuICAgIGNvbnNvbGUubG9nKGNhbWVyYS5wb3NpdGlvbik7IC8vIFt4LCB5LCB6XVxuICAgIGNvbnNvbGUubG9nKGNhbWVyYS50YXJnZXQpOyAvLyBbeCwgeSwgel1cbiAgfSk7XG59O1xuXG5jb25zdCBzZXRDYW1lcmEgPSAoe1xuICBwb3NpdGlvbixcbiAgdGFyZ2V0LFxufToge1xuICBwb3NpdGlvbjogbnVtYmVyW107XG4gIHRhcmdldDogbnVtYmVyW107XG59KSA9PiB7XG4gIGFwaS5zZXRDYW1lcmFMb29rQXQocG9zaXRpb24sIHRhcmdldCwgMik7XG59O1xuXG5jb25zdCBjaGFuZ2VDb2xvciA9IGFzeW5jIChwYXJ0OiBzdHJpbmcsIGNvbG9yQ29kZTogYW55KSA9PiB7XG4gIGxldCBpbmRleCA9IG1hdGVyaWFscy5maW5kSW5kZXgoKG0pID0+IHtcbiAgICByZXR1cm4gbS5uYW1lID09PSBwYXJ0O1xuICB9KTtcblxuICAvL21hdGVyaWFsc1tpbmRleF0uY2hhbm5lbHMuQWxiZWRvUEJSLmNvbG9yID0gW2NvbG9yLnIgLyAyNTUsIGNvbG9yLmcgLyAyNTUsIGNvbG9yLmIgLyAyNTVdO1xuICBtYXRlcmlhbHNbaW5kZXhdLmNoYW5uZWxzLkFsYmVkb1BCUi5jb2xvciA9IFtcbiAgICBjb252ZXJ0UkdCdG9MaW5lYXIoY29sb3JDb2RlLnIpLFxuICAgIGNvbnZlcnRSR0J0b0xpbmVhcihjb2xvckNvZGUuZyksXG4gICAgY29udmVydFJHQnRvTGluZWFyKGNvbG9yQ29kZS5iKSxcbiAgXTtcblxuICBhd2FpdCBhcGkuc2V0TWF0ZXJpYWwobWF0ZXJpYWxzW2luZGV4XSk7XG59O1xuXG5jb25zdCBmYXN0Q2hhbmdlTWFpbkNvbG9yID0gKHsgciwgZywgYiB9OiBhbnkpID0+IHtcbiAgbWF0ZXJpYWxzWzEzXS5jaGFubmVscy5BbGJlZG9QQlIuY29sb3IgPSBbXG4gICAgY29udmVydFJHQnRvTGluZWFyKHIpLFxuICAgIGNvbnZlcnRSR0J0b0xpbmVhcihnKSxcbiAgICBjb252ZXJ0UkdCdG9MaW5lYXIoYiksXG4gIF07XG4gIGFwaS5zZXRNYXRlcmlhbChtYXRlcmlhbHNbMTNdKTtcbn07XG5cbmNvbnN0IGFkZFRleHR1cmUgPSBhc3luYyAoYmFzZTY0OiBzdHJpbmcpID0+IHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlPHN0cmluZz4oKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGFwaS5hZGRUZXh0dXJlKGJhc2U2NCwgZnVuY3Rpb24gKGVycjogc3RyaW5nLCBpZDogc3RyaW5nKSB7XG4gICAgICBpZiAoIWVycikge1xuICAgICAgICByZXNvbHZlKGlkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbn07XG5cbmNvbnN0IHNldFRleHR1cmUgPSAocGFydDogc3RyaW5nLCB0ZXh0dXJlVWlkOiBzdHJpbmcpID0+IHtcbiAgbGV0IGluZGV4ID0gbWF0ZXJpYWxzLmZpbmRJbmRleCgobSkgPT4ge1xuICAgIHJldHVybiBtLm5hbWUgPT09IHBhcnQ7XG4gIH0pO1xuXG4gIG1hdGVyaWFsc1tpbmRleF0uY2hhbm5lbHMuQWxiZWRvUEJSID0geyB0ZXh0dXJlOiB7IHVpZDogdGV4dHVyZVVpZCB9IH07XG4gIG1hdGVyaWFsc1tpbmRleF0uY2hhbm5lbHMuQWxiZWRvUEJSLmZhY3RvciA9IDE7XG5cbiAgYXBpLnNldE1hdGVyaWFsKG1hdGVyaWFsc1tpbmRleF0sICgpID0+IHt9KTtcbn07XG5cbmNvbnN0IHNldFVWc2NhbGUgPSAocGFydDogc3RyaW5nKSA9PiB7XG4gIGxldCBpbmRleCA9IG1hdGVyaWFscy5maW5kSW5kZXgoKG0pID0+IHtcbiAgICByZXR1cm4gbS5uYW1lID09PSBwYXJ0O1xuICB9KTtcbiAgYXBpLnNldFVWU2NhbGUobWF0ZXJpYWxzW2luZGV4XSwgXCJBbGJlZG9QQlJcIiwgMTAsIDEwKTtcbn07XG5cbmNvbnN0IHRvZ2dsZU5vZGUgPSAobm9kZTogc3RyaW5nLCBhY3Rpb246IHN0cmluZykgPT4ge1xuICBsZXQgaW5zdGFuY2VJRCA9IG5vZGVzLmZpbHRlcigocikgPT4ge1xuICAgIHJldHVybiByLm5hbWUgPT09IG5vZGU7XG4gIH0pO1xuICBpZiAoaW5zdGFuY2VJRFswXSkge1xuICAgIGlmIChhY3Rpb24gPT0gXCJzaG93XCIpIHtcbiAgICAgIGFwaS5zaG93KGluc3RhbmNlSURbMF0uaW5zdGFuY2VJRCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFwaS5oaWRlKGluc3RhbmNlSURbMF0uaW5zdGFuY2VJRCk7XG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBjb252ZXJ0Q29sb3IoY29sb3I6IGFueSkge1xuICByZXR1cm4gW2NvbG9yLnIsIGNvbG9yLmcsIGNvbG9yLmJdO1xufVxuXG5jb25zdCBnZW5lcmF0ZVNjcmVlbnNob3QgPSBhc3luYyAoKSA9PiB7XG4gIGxldCBjYW1lcmEgPSB7XG4gICAgcG9zaXRpb246IFstNzEuNzEzMDk0NDU2NTQ5MDQsIC01Ny4xNjg4MTEwNjY5ODE5MywgMzIuMjc4OTM5MzQyOTk5OF0sXG4gICAgdGFyZ2V0OiBbMi43MDEwNTE1MTUxMzg5NjQsIDAuMDAwMDc2Njc3NDkwMjMwOTkxOTEsIDQuMzYwMjk5MDk4MzMyNjQ0XSxcbiAgfTtcbiAgYXdhaXQgYXBpLnNldENhbWVyYUxvb2tBdChjYW1lcmEucG9zaXRpb24sIGNhbWVyYS50YXJnZXQsIDApO1xuICBsZXQgc2NyZWVuc2hvdCA9IGF3YWl0IG1ha2VTY3JlZW5zaG90KCk7XG4gIHJldHVybiBzY3JlZW5zaG90O1xufTtcblxuY29uc3QgbWFrZVNjcmVlbnNob3QgPSBhc3luYyAoKSA9PiB7XG4gIHJldHVybiBuZXcgUHJvbWlzZTxzdHJpbmc+KChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBhcGkuZ2V0U2NyZWVuU2hvdChcbiAgICAgIDcwMCxcbiAgICAgIDM5NCxcbiAgICAgIFwiaW1hZ2UvcG5nXCIsXG4gICAgICBmdW5jdGlvbiAoZXJyb3I6IHN0cmluZywgcmVzdWx0OiBzdHJpbmcpIHtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBiYXNlNjRXaXRob3V0SGVhZGVyID0gcmVzdWx0LnN1YnN0cmluZyhyZXN1bHQuaW5kZXhPZihcIixcIikgKyAxKTtcbiAgICAgICAgICByZXNvbHZlKGJhc2U2NFdpdGhvdXRIZWFkZXIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgKTtcbiAgfSk7XG59O1xuXG5mdW5jdGlvbiBjb252ZXJ0UkdCdG9MaW5lYXIoY29sb3I6IG51bWJlcikge1xuICBsZXQgdmFsdWUgPSBjb2xvciAvIDI1NTtcbiAgaWYgKHZhbHVlIDw9IDAgJiYgdmFsdWUgPD0gMC4wNDA0NSkge1xuICAgIHJldHVybiB2YWx1ZSAvIDEyLjkyO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAoKHZhbHVlICsgMC4wNTUpIC8gMS4wNTUpICoqIDIuNDtcbiAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiBzZXRNZXRhbGxpYyhtYXRlcmlhbDogYW55LCB2YWx1ZTogYm9vbGVhbikge1xuICBpZiAodmFsdWUpIHtcbiAgICBtYXRlcmlhbC5jaGFubmVscy5NZXRhbG5lc3NQQlIuZmFjdG9yID0gMTtcbiAgICBtYXRlcmlhbC5jaGFubmVscy5Sb3VnaG5lc3NQQlIuZmFjdG9yID0gMC42O1xuICB9IGVsc2Uge1xuICAgIG1hdGVyaWFsLmNoYW5uZWxzLk1ldGFsbmVzc1BCUi5mYWN0b3IgPSAwO1xuICAgIG1hdGVyaWFsLmNoYW5uZWxzLlJvdWdobmVzc1BCUi5mYWN0b3IgPSAwLjI7XG4gIH1cbiAgYXdhaXQgYXBpLnNldE1hdGVyaWFsKG1hdGVyaWFsc1sxM10pO1xufVxuXG5mdW5jdGlvbiBlbWlzc2lvbkFuaW1hdGlvbihwYXJ0OiBzdHJpbmcpIHtcbiAgbGV0IGluZGV4ID0gbWF0ZXJpYWxzLmZpbmRJbmRleCgobSkgPT4ge1xuICAgIHJldHVybiBtLm5hbWUgPT09IHBhcnQ7XG4gIH0pO1xuXG4gIGZ1bmN0aW9uIGNoYW5nZUVtaXRGYWN0b3IoaTogbnVtYmVyKSB7XG4gICAgbWF0ZXJpYWxzW2luZGV4XS5jaGFubmVscy5FbWl0Q29sb3IuZW5hYmxlID0gdHJ1ZTtcbiAgICBtYXRlcmlhbHNbaW5kZXhdLmNoYW5uZWxzLkVtaXRDb2xvci5mYWN0b3IgPSBpO1xuICAgIGFwaS5zZXRNYXRlcmlhbChtYXRlcmlhbHNbaW5kZXhdLCAoKSA9PiB7fSk7XG4gIH1cblxuICBsZXQgbnVtYmVyID0gMDtcbiAgbGV0IGluY3JlbWVudCA9IDAuMDI1O1xuXG4gIGZ1bmN0aW9uIGFuaW1hdGVOdW1iZXIoKSB7XG4gICAgbnVtYmVyICs9IGluY3JlbWVudDtcblxuICAgIGlmIChudW1iZXIgPj0gMC40KSB7XG4gICAgICBpbmNyZW1lbnQgPSAtaW5jcmVtZW50O1xuICAgIH1cblxuICAgIGlmIChudW1iZXIgPiAwKSB7XG4gICAgICBzZXRUaW1lb3V0KGFuaW1hdGVOdW1iZXIsIDEwKTsgLy8gTGxhbWFyIGEgbGEgZnVuY2nDs24gbnVldmFtZW50ZSBkZXNwdcOpcyBkZSAxMCBtaWxpc2VndW5kb3NcbiAgICB9XG5cbiAgICBjaGFuZ2VFbWl0RmFjdG9yKG51bWJlcik7XG4gIH1cbiAgYW5pbWF0ZU51bWJlcigpO1xufVxuZXhwb3J0IHtcbiAgaW5pdFNlcnZpY2UsXG4gIGNoYW5nZUNvbG9yLFxuICBhZGRUZXh0dXJlLFxuICBzZXRUZXh0dXJlLFxuICBnZXRNYXRlcmlhbHMsXG4gIGdldE5vZGVMaXN0LFxuICB0b2dnbGVOb2RlLFxuICBnZW5lcmF0ZVNjcmVlbnNob3QsXG4gIHNldE1ldGFsbGljLFxuICBmYXN0Q2hhbmdlTWFpbkNvbG9yLFxuICBzZXRVVnNjYWxlLFxuICBlbWlzc2lvbkFuaW1hdGlvbixcbiAgZ2V0Q2FtZXJhLFxuICBzZXRDYW1lcmEsXG59O1xuIl0sIm5hbWVzIjpbImFwaSIsIm1hdGVyaWFscyIsIm5vZGVzIiwiaW5pdFNlcnZpY2UiLCJhcGlSZWYiLCJtYXRlcmlhbExpc3QiLCJub2RlTGlzdCIsImNvbnNvbGUiLCJsb2ciLCJnZXRNYXRlcmlhbHMiLCJnZXROb2RlTGlzdCIsImdldENhbWVyYSIsImdldENhbWVyYUxvb2tBdCIsImVyciIsImNhbWVyYSIsInBvc2l0aW9uIiwidGFyZ2V0Iiwic2V0Q2FtZXJhIiwic2V0Q2FtZXJhTG9va0F0IiwiY2hhbmdlQ29sb3IiLCJwYXJ0IiwiY29sb3JDb2RlIiwiaW5kZXgiLCJmaW5kSW5kZXgiLCJtIiwibmFtZSIsImNoYW5uZWxzIiwiQWxiZWRvUEJSIiwiY29sb3IiLCJjb252ZXJ0UkdCdG9MaW5lYXIiLCJyIiwiZyIsImIiLCJzZXRNYXRlcmlhbCIsImZhc3RDaGFuZ2VNYWluQ29sb3IiLCJhZGRUZXh0dXJlIiwiYmFzZTY0IiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJpZCIsInNldFRleHR1cmUiLCJ0ZXh0dXJlVWlkIiwidGV4dHVyZSIsInVpZCIsImZhY3RvciIsInNldFVWc2NhbGUiLCJzZXRVVlNjYWxlIiwidG9nZ2xlTm9kZSIsIm5vZGUiLCJhY3Rpb24iLCJpbnN0YW5jZUlEIiwiZmlsdGVyIiwic2hvdyIsImhpZGUiLCJjb252ZXJ0Q29sb3IiLCJnZW5lcmF0ZVNjcmVlbnNob3QiLCJzY3JlZW5zaG90IiwibWFrZVNjcmVlbnNob3QiLCJnZXRTY3JlZW5TaG90IiwiZXJyb3IiLCJyZXN1bHQiLCJiYXNlNjRXaXRob3V0SGVhZGVyIiwic3Vic3RyaW5nIiwiaW5kZXhPZiIsInZhbHVlIiwic2V0TWV0YWxsaWMiLCJtYXRlcmlhbCIsIk1ldGFsbmVzc1BCUiIsIlJvdWdobmVzc1BCUiIsImVtaXNzaW9uQW5pbWF0aW9uIiwiY2hhbmdlRW1pdEZhY3RvciIsImkiLCJFbWl0Q29sb3IiLCJlbmFibGUiLCJudW1iZXIiLCJpbmNyZW1lbnQiLCJhbmltYXRlTnVtYmVyIiwic2V0VGltZW91dCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./utils/sketchfab.ts\n"));

/***/ })

});